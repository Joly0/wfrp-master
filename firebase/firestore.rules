rules_version = '2';

service cloud.firestore {
    match /databases/{database}/documents {
   
        match /parties/{party=**} {
            allow read: if request.auth.uid != null
                        && request.auth.uid in resource.data.users;
        }

        match /parties/{partyId} {
            allow create: if request.auth != null && isValidNewParty(request.resource.data, request.auth.uid);
            allow write: if request.auth != null
                         && ((isGameMaster() && isValidPartyEdit()) || onlyUserAdded());


            match /encounters/{encounterId} {
                allow read: if hasAccessToParty();
                allow create: if isValidEncounter(request.resource.data)
                            && hasAccessToParty()
                            && isGameMaster();
                allow update: if isValidEncounter(request.resource.data)
                              && hasAccessToParty()
                              && isGameMaster();
                allow delete: if hasAccessToParty() && isGameMaster();

                match /combatants/{combatantId} {
                    allow read: if hasAccessToParty();

                    allow create: if isValidCombatant(request.resource.data)
                                && hasAccessToParty()
                                && isGameMaster();
                    allow update: if isValidCombatant(request.resource.data)
                                && hasAccessToParty()
                                && isGameMaster();
                    allow delete: if hasAccessToParty() && isGameMaster();

                    function isValidCombatant(combatant) {
                        return combatant is map
                            && combatant.keys().toSet() == ["id", "name", "note", "wounds", "stats", "armor", "enemy", "alive", "traits", "trappings", "position"].toSet()
                            && combatant.id is string && isValidUuid(combatant.id) && combatant.id == combatantId
                            && combatant.name is string && isNotBlank(combatant.name) && combatant.name.size() <= 100
                            && combatant.note is string && combatant.note.size() <= 400
                            && areValidWounds(combatant.wounds)
                            && areStatsValid(combatant.stats)
                            && isArmorValid(combatant.armor)
                            && combatant.enemy is bool
                            && combatant.alive is bool
                            && combatant.traits is list
                            && combatant.trappings is list
                            && combatant.position is number && combatant.position >= 0;
                    }

                    function areValidWounds(wounds) {
                        return wounds is map
                           && wounds.keys().toSet() == ["max", "current"].toSet()
                           && wounds.max is int && wounds.max > 0
                           && wounds.current is int && wounds.current >= 0 && wounds.current <= wounds.max;
                    }
                }

                function isValidEncounter(encounter) {
                    return encounter is map
                        && encounter.keys().toSet() == ["id", "name", "description", "position", "completed"].toSet()
                        && encounter.id is string && encounter.id == encounterId
                        && encounter.name is string && isNotBlank(encounter.name) && encounter.name.size() <= 100
                        && encounter.description is string && encounter.description.size() <= 1000
                        && encounter.position is int && encounter.position >= 0
                        && encounter.completed is bool;
                }
            }

            match /characters/{userId} {
                allow create: if hasAccessToParty()
                                && userId == request.auth.uid
                                && isValidCharacter(request.resource.data);
                allow update: if canEditCharacter()
                              && isValidCharacter(request.resource.data);
                allow read: if hasAccessToParty();

                match /inventory/{itemId} {
                    allow read: if hasAccessToParty();
                    allow create: if canEditCharacter() && isValidInventoryItem(request.resource.data);
                    allow update: if canEditCharacter() && isValidInventoryItem(request.resource.data);
                    allow delete: if canEditCharacter();

                    function isValidInventoryItem(item) {
                        return item.keys().toSet() == ["id", "name", "description", "quantity"].toSet()
                            && item.id is string && item.id == itemId && isValidUuid(item.id)
                            && item.name is string && isNotBlank(item.name) && item.name.size() <= 50
                            && item.description is string && item.description.size() <= 200
                            && item.quantity is int && item.quantity > 0;
                    }
                }

                match /skills/{skillId} {
                    allow read: if hasAccessToParty();
                    allow create: if canEditCharacter() && isValidSkill(request.resource.data);
                    allow update: if canEditCharacter() && isValidSkill(request.resource.data);
                    allow delete: if canEditCharacter();

                    function isValidSkill(skill) {
                        return skill.keys().toSet() == ["id", "name", "description", "advanced", "characteristic", "advances"].toSet()
                            && skill.id is string && skill.id == skillId && isValidUuid(skill.id)
                            && skill.name is string && isNotBlank(skill.name) && skill.name.size() <= 50
                            && skill.description is string && skill.description.size() <= 200
                            && skill.advanced is bool
                            && skill.advances is int && skill.advances >= 0
                            && skill.characteristic in [
                                "AGILITY",
                                "BALLISTIC_SKILL",
                                "DEXTERITY",
                                "INITIATIVE",
                                "INTELLIGENCE",
                                "FELLOWSHIP",
                                "STRENGTH",
                                "TOUGHNESS",
                                "WILL_POWER",
                                "WEAPON_SKILL"
                            ]
                    }
                }

                match /talents/{talentId} {
                    allow read: if hasAccessToParty();
                    allow create: if canEditCharacter() && isValidTalent(request.resource.data);
                    allow update: if canEditCharacter() && isValidTalent(request.resource.data);
                    allow delete: if canEditCharacter();

                    function isValidTalent(talent) {
                        return talent.keys().toSet() == ["id", "name", "description", "taken"].toSet()
                            && talent.id is string && talent.id == talentId && isValidUuid(talent.id)
                            && talent.name is string && isNotBlank(talent.name) && talent.name.size() <= 50
                            && talent.description is string && talent.description.size() <= 200
                            && talent.taken is int && talent.taken >= 1 && talent.taken <= 999;
                    }
                }

                match /spells/{spellId} {
                    allow read: if hasAccessToParty();
                    allow create: if canEditCharacter() && isValidSpell(request.resource.data);
                    allow update: if canEditCharacter() && isValidSpell(request.resource.data);
                    allow delete: if canEditCharacter();

                    function isValidSpell(spell) {
                        return spell.keys().toSet() == ["id", "name", "range", "target", "duration", "castingNumber", "effect"].toSet()
                            && spell.id is string && spell.id == spellId && isValidUuid(spell.id)
                            && spell.name is string && isNotBlank(spell.name) && spell.name.size() <= 50
                            && spell.range is string && spell.range.size() <= 50
                            && spell.target is string && spell.target.size() <= 50
                            && spell.duration is string && spell.duration.size() <= 50
                            && spell.effect is string && spell.effect.size() <= 400
                            && spell.castingNumber is int && spell.castingNumber >= 0 && spell.castingNumber <= 99;
                    }
                }

                match /features/{featureName} {
                    allow read: if hasAccessToParty();
                    allow create: if canEditCharacter() && isValidFeature(request.resource.data);
                    allow update: if canEditCharacter() && isValidFeature(request.resource.data);


                    function isValidFeature(data) {
                        return featureName == "armor" && isArmorValid(data);
                    }
                }

                function areMoneyValid(money) {
                    return money is map
                        && money.keys().toSet() == ["pennies"].toSet()
                        && money.pennies is int && money.pennies >= 0;
                }

                function canEditCharacter() {
                    return hasAccessToParty()
                        && (isGameMaster() || request.auth.uid == userId);
                }

                function isValidCharacter(character) {
                    return [
                            "name",
                            "career",
                            "socialClass",
                            "points",
                            "race",
                            "stats",
                            "characteristicsBase",
                            "characteristicsAdvances",
                            "maxStats",
                            "userId",
                            "money",
                            "motivation",
                            "psychology",
                            "mutation",
                            "ambitions",
                            "note",
                            "hardyTalent"
                        ].hasAll(character.keys())
                        && character.userId == userId
                        && character.name is string && isNotBlank(character.name) && character.name.size() <= 50
                        && character.career is string && isNotBlank(character.career) && character.career.size() <= 50
                        && character.psychology is string && character.psychology.size() <= 200
                        && character.motivation is string && character.motivation.size() <= 200
                        && character.mutation is string && character.mutation.size() <= 200
                        && character.socialClass is string && isNotBlank(character.socialClass) && character.socialClass.size() <= 50
                        && character.race is string && character.race in ["HUMAN", "HIGH_ELF", "DWARF", "HALFLING", "WOOD_ELF", "GNOME"]
                        && arePointsValid(character.points)
                        && ("stats" in character || "characteristicsBase" in character)
                        && (! ("stats" in character) || areStatsValid(character.stats))
                        && (! ("characteristicsBase" in character) || areStatsValid(character.characteristicsBase))
                        && (! ("characteristicsAdvances" in character) || areStatsValid(character.characteristicsAdvances))
                        && areMoneyValid(character.money)
                        && areAmbitionsValid(character.ambitions)
                        && character.note is string && character.note.size() <= 400
                        && (! ("hardyTalent" in character) || (character.hardyTalent is bool));
                }
            }

            function arePointsValid(points) {
                return points is map
                    && [
                        "corruption",
                        "experience",
                        "fate",
                        "fortune",
                        "maxWounds",
                        "resilience",
                        "resolve",
                        "sin",
                        "wounds",
                        "hardyWoundsBonus"
                    ].hasAll(points.keys())
                    && points.corruption is int
                    && points.fate is int
                    && points.fortune is int
                    && points.maxWounds is int
                    && points.resilience is int
                    && points.resolve is int
                    && points.sin is int
                    && points.wounds is int
                    && points.experience is int
                    && (! ("hardyWoundsBonus" in points) || (points.hardyWoundsBonus is int && points.hardyWoundsBonus >= 0));
            }

            function areStatsValid(stats) {
                return stats is map
                    && stats.keys().toSet() == [
                        "agility",
                        "ballisticSkill",
                        "dexterity",
                        "fellowship",
                        "initiative",
                        "intelligence",
                        "strength",
                        "toughness",
                        "weaponSkill",
                        "willPower"
                    ].toSet()
                    && stats.agility is int
                    && stats.ballisticSkill is int
                    && stats.dexterity is int
                    && stats.fellowship is int
                    && stats.initiative is int
                    && stats.intelligence is int
                    && stats.strength is int
                    && stats.toughness is int
                    && stats.weaponSkill is int
                    && stats.willPower is int;
            }

            function isArmorValid(armor) {
                return armor is map
                    && armor.keys().toSet() == ["head", "body", "leftArm", "rightArm", "leftLeg", "rightLeg", "shield"].toSet()
                    && armor.head is int && armor.head >= 0 && armor.head <= 99
                    && armor.body is int && armor.body >= 0 && armor.body <= 99
                    && armor.leftArm is int && armor.leftArm >= 0 && armor.leftArm <= 99
                    && armor.rightArm is int && armor.rightArm >= 0 && armor.rightArm <= 99
                    && armor.leftLeg is int && armor.leftLeg >= 0 && armor.leftLeg <= 99
                    && armor.rightLeg is int && armor.rightLeg >= 0 && armor.rightLeg <= 99
                    && armor.shield is int && armor.shield >= 0 && armor.shield <= 99;
            }


            function isValidUuid(maybeUuid) {
                return maybeUuid.matches("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }

            function areAmbitionsValid(ambitions) {
                return ambitions is map && ambitions.keys().toSet() == ["shortTerm", "longTerm"].toSet()
                    && ambitions.shortTerm is string && ambitions.shortTerm.size() <= 400
                    && ambitions.longTerm is string && ambitions.longTerm.size() <= 400;
            }

            function isValidPartyName(name) {
                return name is string && isNotBlank(name) && name.size() <= 50;
            }

            function isValidNewParty(party, uid) {
                return ["id", "name", "users", "gameMasterId", "accessCode", "ambitions", "archived"].hasAll(party.keys())
                    && party.id is string && party.id == partyId && isValidUuid(party.id)
                    && isValidPartyName(party.name)
                    && party.users == [uid]
                    && (! ("archived" in party) || party.archived is bool)
                    && (party.gameMasterId == uid || party.gameMasterId == null)
                    && party.accessCode is string && party.accessCode != ""
                    && areAmbitionsValid(party.ambitions);
            }

            function isValidPartyEdit() {
                let party = request.resource.data;
                let diff = resource.data.diff(request.resource.data);

                return ["ambitions", "name", "archived"].toSet().hasAll(diff.affectedKeys())
                    && areAmbitionsValid(party.ambitions)
                    && isValidPartyName(party.name)
                    && (! ("archived" in party) || party.archived is bool)
            }

            function invitation(party) {
                return {"partyId": party.id, "accessCode": party.accessCode};
            }

            function hasInvitation(userId, invitation) {
                return invitation in get(/databases/$(database)/documents/users/$(userId)).data.invitations;
            }

            function isGameMaster() {
                let party = get(/databases/$(database)/documents/parties/$(partyId)).data;

                return request.auth != null
                    && (request.auth.uid == party.gameMasterId || (request.auth.uid in party.users && party.gameMasterId == null));
            }
        
            function hasAccessToParty() {
                return request.auth != null
                    && request.auth.uid in get(/databases/$(database)/documents/parties/$(partyId)).data.users
            }

            function onlyUserAdded() {
                let userId = request.auth.uid;
                let diff = resource.data.diff(request.resource.data);
                let originalUsers = resource.data.users;
                let newUsers = request.resource.data.users;
                let invitation = invitation(resource.data);

                return diff.affectedKeys() == ["users"].toSet()
                    && hasInvitation(userId, invitation)
                    && originalUsers.toSet().union([userId].toSet()) == newUsers.toSet();
            }
        }

        match /users/{user} {
            allow write: if request.auth.uid != null && user == request.auth.uid && isValidUser(request.resource.data);

            function isValidUser(data) {
                return data.keys() == ["invitations"] && data.invitations is list
            }
        }
    }

    //
    // Returns true if string contains at least one character that is not a whitespace
    //
    function isNotBlank(value) {
        return value.replace('\\s', '') != ""
    }
}
