rules_version = '2';

service cloud.firestore {
    match /databases/{database}/documents {
   
        match /parties/{party=**} {
            allow read: if request.auth.uid != null
                        && request.auth.uid in resource.data.users;
        }

        match /parties/{partyId} {
            allow create: if request.auth != null;
            allow write: if request.auth != null && onlyUserAdded();

            match /characters/{userId} {
                allow write: if hasAccessToParty()
                                && request.resource.data.userId == userId
                                && request.resource.data.userId == request.auth.uid;
                allow read: if hasAccessToParty();
            }

            function invitation(party) {
                return {"partyId": party.id, "accessCode": party.accessCode};
            }

            function hasInvitation(userId, invitation) {
                return invitation in get(/databases/$(database)/documents/users/$(userId)).data.invitations;
            }

            function hasAccessToParty() {
                return request.auth.uid != null
                    && request.auth.uid in get(/databases/$(database)/documents/parties/$(partyId)).data.users
            }

            function onlyUserAdded() {
                let userId = request.auth.uid;
                let diff = resource.data.diff(request.resource.data);
                let originalUsers = resource.data.users;
                let newUsers = request.resource.data.users;
                let invitation = invitation(resource.data);

                return diff.affectedKeys() == ["users"].toSet()
                    && hasInvitation(userId, invitation)
                    && originalUsers.toSet().union([userId].toSet()) == newUsers.toSet();
            }
        }

        match /users/{user} {
            allow write: if user == request.auth.uid
        }
    }
}
